---
title: 가장 긴 증가하는 부분 수열
number: 11053
level: silver
from: baekjoon
url: https://www.acmicpc.net/problem/11053
---

## 문제 분석

알고리즘: DP

해당 문제는 주어진 수열에서 오름차순으로 증가하는 원소들만으로 가장 긴 길이를 찾는 문제로,

주어진 수열들을 순회하면서 **각 수열이 가질 수 있는, 오름차순을 이루는 수열의 길이**를 구하면 된다.

이는 이중 반복문으로 구현할 수 있을 것이다.

예제로, 수열 **\{10, 20, 10, 30, 20, 50\}** 이 주어질 때, 이를 배열 변수 `A` 라고 하고,
오름차순을 이루는 수열의 길이를 메모제이션할 배열 변수를 `DP` 라고 가정해보자.

- `A[0]` - 이전 값이 없으므로 기본적으로 1의 길이를 갖는다. 즉, `DP[0]=1`이 된다.
  > 모든 부분 수열의 길이는 1을 기본으로한다.
- `A[1]` - 이전의 값이 `A[0]=10` 이므로, `A[1]`보다 작기 때문에 오름차순을 이루는 부분 수열 {10, 20} 을 이룬다. `DP[1]=2`
- `A[2]` - 이전 값들 중 작은 값이 없기 때문에 1개의 길이를 갖는다. `DP[2]=1`
- `A[3]` - 이전 값들 오름차순을 이루는 부분 수열 {10, 20, 30} 을 갖는다. `DP[3]=3`
- `A[4]` - 이전 값들 오름차순을 이루는 부분 수열 {10, 20} 을 갖는다. 수열의 길이는 2. `DP[4]=2`
- `A[5]` - 이전 값들 오름차순을 이루는 부분 수열 {10, 20, 30, 50} 을 갖는다. 수열의 길이는 4. `DP[4]=4`

표로 보면 다음과 같다.

| A   | 10  | 20  | 10  | 30  | 20  | 50  |
| --- | --- | --- | --- | --- | --- | --- |
| DP  | 1   | 2   | 1   | 3   | 2   | 4   |

## 풀이

```js
const [N, input] = require('fs').readFileSync('dev/stdin').toString().split('\n');
const n = parseInt(N);
const a = input.split(' ').map(Number);

const dp = new Array(n).fill(1);

for (let i = 0; i < n; i++) {
  for (let j = 0; j < i; j++) {
    if (a[j] < a[i] && dp[i] < dp[j] + 1) {
      dp[i] = dp[j] + 1;
    }
  }
}

console.log(Math.max(...dp));
```
